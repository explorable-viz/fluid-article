def and(False, y): False
def and(True, y): y

def or(True, y): True
def or(False, y): y

def not(True): False
def not(False): True

def compare(x, y):
  if x > y: GT
  else:
    if x < y: LT
    else: EQ

def negate: (-)(0)

def logBase(x, y): log(y) / log(x)

def ceilingToNearest(n, m): ceiling(n / m) * m

def compose(f, g, x): f(g(x))

def curry(f, x, y): f((x, y))

def uncurry(f, (x, y)): f(x, y)

def const(x, _): x

def first(f, (a, c)): (f(a), c)

def snd((_, y)): y

def second(f, (c, a)): (c, f(a))

def flip(f, x, y): f(y, x)

def fst((x, _)): x

def id(x): x

def prod(f, g, x): (f(x), g(x))

def swap((a, b)): (b, a)

def head([]):
  error("Can't take head of empty list")
def head(x :| _): x

def tail([]):
  error("Can't take tail of empty list")
def tail(_ :| xs): xs

def elem(x, []): False
def elem(x, y :| xs):
  x == y |or| elem(x, xs)

def find(p, []): error("not found")
def find(p, x :| xs):
  if p(x): Some(x)
  else: find(p, xs)

def findWithKey(fname, fval, table):
  find((lambda y: y[fname] == fval), table)

def fromSome(option):
  match option:
    case None:
      error("Expected Some!")
    case Some(x): x

def filter(p, []): []
def filter(p, x :| xs):
  def ys: filter(p, xs)

  if p(x): x :| ys
  else: ys

def filterMap(p, []): []
def filterMap(p, x :| xs):
  match p(x):
    case None: filterMap(f, xs)
    case Some(y):
      y :| filterMap(f, xs)

def foldl(op, z, []): z
def foldl(op, z, x :| xs):
  foldl(op, op(z, x), xs)

def foldl1(op, x :| xs): foldl(op, x, xs)

def foldr(op, z, []): z
def foldr(op, z, x :| xs):
  op(x, foldr(op, z, xs))

def foldr1(op, [x]): x
def foldr1(op, x :| y :| xs):
  op(x, foldr1(op, y :| xs))

def scanl1(op, z, xs):
  def go(x, continue, acc):
    def next: op(acc, x)

    next :| continue(next)

  foldr(go, const([]), xs, z)

def scanl(op, z, xs):
  z :| scanl1(op, z, xs)

def map(f, []): []
def map(f, x :| xs): f(x) :| map(f, xs)

def append(([], ys)): ys
def append((x :| xs, ys)):
  x :| append((xs, ys))

def concat2([], ys): ys
def concat2(x :| xs, ys):
  x :| concat2(xs, ys)

def concat: foldl(concat2, [])

def concatMap(f, xs): concat(map(f, xs))

def intersperse([], _): []
def intersperse([x], _): [x]
def intersperse(x :| y :| ys, sep):
  x :| sep :| intersperse(y :| ys, sep)

def iterate(n, f, z):
  if n == 0: []
  else:
    z :| map(f, iterate(n - 1, f, z))

def sum: foldr((+), 0)

def last([x]): x
def last(x :| y :| ys): last(y :| ys)

def length([]): 0
def length(_ :| xs): 1 + length(xs)

def reverse([]): []
def reverse(x :| xs):
  append((reverse(xs), [x]))

def repeat: flip(iterate, id)

def take(n, xs):
  if n <= 0: []
  else:
    match xs:
      case []: []
      case x :| xs:
        x :| take(n - 1, xs)

def drop(n, xs):
  if n <= 0: xs
  else:
    match xs:
      case []: []
      case _ :| xs: drop(n - 1, xs)

def lastN(n, xs):
  foldl(compose(const, drop(1)), xs, drop(n, xs))

def nth(n, x :| xs):
  if n == 0: x
  else: nth(n - 1, xs)

def nth2(i, j, xss):
  nth(j - 1, nth(i - 1, xss))

def lookup(k, []):
  error("Key not found in map")
def lookup(k, (k_, v) :| kvs):
  if k == k_: v
  else: lookup(k, kvs)

def max(n, m):
  if n > m: n
  else: m

def min(n, m):
  if n < m: n
  else: m

def maximum: foldr1(max)

def minimum: foldr1(min)

def unzip([]): ([], [])
def unzip((x, y) :| zs):
  def (xs, ys): unzip(zs)

  (x :| xs, y :| ys)

def zipWith(op, [], ys): []
def zipWith(op, x :| xs, []): []
def zipWith(op, x :| xs, y :| ys):
  op(x, y) :| zipWith(op, xs, ys)

def zip: zipWith(curry(id))

def enumFromTo(n, m):
  if n <= m: n :| [n + 1 .. m]
  else: []

def range((m1, n1), (m2, n2)):
  [(i1, i2) for i1 in [m1 .. m2] for i2 in [n1 .. n2]]

def abs(x, y):
  if x - y < 0: negate(x - y)
  else: x - y

def nub(xs):
  def nub_([], _): []
  def nub_(x :| xs, ys):
    if x |elem| ys: nub_(xs, ys)
    else:
      x :| nub_(xs, x :| ys)

  nub_(xs, [])

def slice(begin, end, xs):
  take(end - begin, drop(begin, xs))

def splitOn(p, data):
  def go(fls, trs, []):
    (reverse(fls), reverse(trs))
  def go(fls, trs, x :| xs):
    if p(x):
      go(fls, x :| trs, xs)
    else:
      go(x :| fls, trs, xs)

  go([], [], data)
