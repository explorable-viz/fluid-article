def split([]): ([], [])
def split(x :| xs):
  def (ys, zs): split(xs)
  (x :| zs, ys)

def merge(xs, ys):
  match (xs, ys):
    case ([], _): ys
    case (x :| xs_, []): xs
    case (x :| xs_, y :| ys_):
      if x < y: x :| merge(xs_, ys)
      else: y :| merge(xs, ys_)

def mergesort(xs):
  if length(xs) < 2: xs
  else:
    def (ys, zs): split(xs)
    merge(mergesort(ys), mergesort(zs))

def findQuantile(q, p, xs):
  def rank:
    (p / q) * (length(xs) - 1)

  if rank == floor(rank):
    nth(rank, xs)
  else:
    def x1: floor(rank)
    def x2: ceiling(rank)
    def left: nth(x1, xs)
    def right: nth(x2, xs)
    left + (rank - x1) * (right - left)

def findPercentile: findQuantile(100)

def accumBins(data, Nil): []
def accumBins(data, [l]): []
def accumBins(data, l :| r :| es):
  def (ge, le):
    splitOn(lambda x: x <= r, data)
  (le, r - l) :| accumBins(ge, r :| es)

def cut(xs, nbins):
  def low: minimum(xs)
  def binwidth:
    (maximum(xs) - low) / nbins
  def edges:
    [low + x * binwidth for x in enumFromTo(0, nbins)]

  accumBins(xs, edges)

def qcut(xs, qs):
  def (low, high):
    (minimum(xs), maximum(xs))
  def edges:
    append((low :| [findPercentile(x, xs) for x in qs], [high]))

  accumBins(xs, edges)

def likelihoodLE(xs, target):
  length(filter(lambda x: x <= target, xs)) / length(xs)

def likelihoodGE(xs, target):
  length(filter(lambda x: x >= target, xs)) / length(xs)

def likelihoodMap(table, prob):
  fromSome(find(lambda x: x.prob <= prob, table)).msg

def mkPercent(num):
  numToStr(num * 100) ++ "%"

def leqP(n, m):
  if n <= m: "less"
  else: "more"

def gradedLeqP(n, m):
  def ratio: n / m

  if ratio <= 1.0:
    if ratio <= 0.5: "much less"
    else: "less"
  else:
    if ratio >= 2.0: "much more"
    else: "more"
