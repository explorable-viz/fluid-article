# type Colour = Str
# type Colours = List Colour
# type Cat = Str

# Group has location (0, 0) because it doesn't interfere with positioning of its children.
# GraphicsElement -> Point
def coords(Group(gs)): Point(0, 0)
def coords(Rect(x, y, _, _, _)): Point(x, y)
def coords(String(x, y, _, _, _)): Point(x, y)
def coords(Viewport(x, y, _, _, _, _, _, _, _)): Point(x, y)

# GraphicsElement -> Float
def get_x(g):
  def Point(x, _): coords(g)
  x

# GraphicsElement -> Float
def get_y(g):
  def Point(_, y): coords(g)
  y

# Want some kind of typeclass mechanism plus record accessors/updaters.
# Float -> GraphicsElement -> GraphicsElement
def set_x(x, Group(gs)):
  error("Group has immutable coordinates")
def set_x(x, Rect(_, y, w, h, fill)):
  Rect(x, y, w, h, fill)
def set_x(x, String(_, y, str, anchor, baseline)):
  String(x, y, str, anchor, baseline)
def set_x(x, Viewport(_, y, w, h, fill, margin, scale, translate, g)):
  Viewport(x, y, w, h, fill, margin, scale, translate, g)

# (Point, Point) -> Point
def dimensions2((Point(x1, y1), Point(x2, y2))):
  Point(max(x1, x2), max(y1, y2))

# For Group, dimensions are relative to implicit coords of (0, 0), since a Group's children are effectively
# positioned relative to parent of Group. For Polymarker, will probably have to ignore the markers themselves,
# since they are scale-invariant.
# GraphicsElement -> Point
def dimensions(Group(gs)):
  foldl(curry(dimensions2), Point(0, 0), map(coords_op, gs))
def dimensions(Polyline(ps, _, _)):
  foldl(curry(dimensions2), Point(0, 0), ps)
def dimensions(Rect(_, _, w, h, _)): Point(w, h)
def dimensions(String(_, _, _, _, _)): Point(0, 0)
def dimensions(Viewport(_, _, w, h, _, _, _, _, _)): Point(w, h)

def coords_op(g):
  def (Point(x, y), Point(w, h)):
    prod(coords, dimensions, g)
  Point(x + w, y + h)

# GraphicsElement -> Float
def width(g):
  def Point(w, _): dimensions(g)
  w

# GraphicsElement -> Float
def height(g):
  def Point(_, h): dimensions(g)
  h

# Float -> Float -> List GraphicsElement -> List GraphicsElement
def spaceRight(z, sep, gs):
  zipWith(set_x, iterate(length(gs), (+)(sep), z), gs)

# Bake colour decisions into the library for the time being. Provide two palettes, so we can have two
# different sets of categorical values (e.g. countries and energy types). Palettes from colorbrewer2.org
def colours1: [
  "#66c2a5",
  "#a6d854",
  "#ffd92f",
  "#e5c494",
  "#fc8d62",
  "#b3b3b3",
  "#8da0cb",
  "#e78ac3"
]

def colours2: [
  "#e41a1c",
  "#377eb8",
  "#4daf4a",
  "#984ea3",
  "#ff7f00",
  "#ffff33",
  "#a65628",
  "#f781bf"
]

# Compositionality principle: child coords/dimensions are always expressed directly using parent reference
# frame, to avoid depending on content of child, and so are not themselves scaled. Polyline can't be scaled
# directly because it inherits its frame of reference from its parent. For Viewport, margin will shrink the
# available area, possibly to zero, at which point nothing will be rendered.
# Float -> GraphicsElement -> GraphicsElement
def scaleToWidth(w, Rect(x, y, _, h, fill)):
  Rect(x, y, w, h, fill)
def scaleToWidth(w, Viewport(x, y, w0, h, fill, margin, Scale(x_scale, y_scale), translate, g)):
  def scale: Scale((x_scale * w) / w0, y_scale)
  Viewport(x, y, w, h, fill, margin, scale, translate, g)

# Float -> List GraphicsElement -> List GraphicsElement
def stackRight(sep, gs):
  map(scaleToWidth(1 - sep), spaceRight(sep / 2, 1, gs))

# Float -> List GraphicsElement -> GraphicsElement
def groupRight(sep, gs):
  Viewport(0, 0, length(gs), maximum(map(height, gs)), "none", 0, Scale(1, 1), Translate(0, 0), Group(stackRight(sep, gs)))

# Heuristic saying how often to place a tick on an axis of length n.
# Float -> Float
def tickEvery(n):
  def m: floor(logBase(10, n))

  if n <= 2 * 10 ** m: 2 * 10 ** (m - 1)
  else: 10 ** m

def axisStrokeWidth: 0.5
def axisColour: "black"
def backgroundColour: "white"
def defaultMargin: 24
def markerRadius: 3.5
def tickLength: 4

# Helpers for axis functions.
# Orient -> Colour -> Float -> GraphicsElement
def tick(Horiz, colour, len):
  Line(Point(0, 0), Point(0, 0 - len), colour, axisStrokeWidth)
def tick(Vert, colour, len):
  Line(Point(0, 0), Point(0 - len, 0), colour, axisStrokeWidth)

# Orient -> Float -> Float -> Str -> GraphicsElement
def label(Horiz, x, distance, str):
  String(x, (0 - distance) - 4, str, "middle", "hanging")
def label(Vert, x, distance, str):
  String(0 - distance, x, str, "end", "central")

# Orient -> Colour -> Float -> Str -> GraphicsElement
def labelledTick(orient, colour, len, str):
  Group([
    tick(orient, colour, len),
    label(orient, 0, len, str)
  ])

# Orient -> Float -> Float -> Point
def mkPoint(Horiz, x, y): Point(y, x)
def mkPoint(Vert, x, y): Point(x, y)

# x is position of this axis on the other axis. Returns axis and position of last tick.
# Orient -> Float -> Float -> Float -> GraphicsElement
def axis(orient, x, start, end):
  def tickSp: tickEvery(end - start)
  def firstTick: ceilingToNearest(start, tickSp)
  def lastTick: ceilingToNearest(end, tickSp)
  def n: floor((end - firstTick) / tickSp) + 1
  def ys: iterate(n, (+)(tickSp), firstTick)
  def ys:
    if firstTick > start: start :| ys
    else: ys
  def ys:
    if lastTick > end: concat2(ys, [lastTick])
    else: ys
  def ps: map(mkPoint(orient, x), ys)
  def ax:
    Group([
      Line(head(ps), last(ps), axisColour, axisStrokeWidth),
      Polymarkers(ps, flip(map, ys, compose(labelledTick(orient, axisColour, tickLength), numToStr)))
    ])

  (ax, lastTick)

# x is position of this axis on the other axis.
# Orient -> Float -> List Cat -> GraphicsElement
def catAxis(orient, x, catValues):
  def ys: iterate(length(catValues) + 1, (+)(1), 0)
  def ps: map(mkPoint(orient, x), ys)

  Group([
    Line(head(ps), last(ps), axisColour, axisStrokeWidth),
    Polymarkers(tail(ps), map(const(tick(orient, axisColour, tickLength)), catValues)),
    Polymarkers(flip(map, tail(ps), lambda Point(x, y): Point(x - 0.5, y)), map(label(orient, -0.5, 0), catValues))
  ])

# Float -> Float -> Float -> Float -> List GraphicsElement -> GraphicsElement
def viewport(x_start, x_finish, y_finish, margin, gs):
  Viewport(0, 0, x_finish - x_start, y_finish, backgroundColour, margin, Scale(1, 1), Translate(0 - x_start, 0), Group(gs))

# Plot a map of x values to lists of (categorical value, y value) pairs. Importantly, assume all data is uniform
# (categorical keys are the same for each x value and are ordered the same each time).
# Bool -> Colours -> Float -> List (Float, List (Cat, Float)) -> GraphicsElement
def lineChart(withAxes, colours, x_start, data):
  def xs: map(fst, data)
  def nCat: length(snd(head(data)))

  # (Int, Colour) -> GraphicsElement
  def plot((n, colour)):
    def ps:
      map(lambda (x, kvs): Point(x, snd(nth(n, kvs))), data)

    Group([
      Polyline(ps, colour, 1),
      Polymarkers(ps, repeat(length(ps), Circle(0, 0, markerRadius, colour)))
    ])

  # List GraphicsElement
  def lines:
    zipWith(curry(plot), iterate(nCat, (+)(1), 0), colours)
  def x_finish: last(xs)
  def y_finish:
    maximum(flip(map, data, lambda (_, kvs): maximum(map(snd, kvs))))

  if withAxes:
    def (x_axis, x_finish): axis(Horiz, 0, x_start, x_finish)
    def (y_axis, y_finish_): axis(Vert, x_start, 0, y_finish)
    viewport(x_start, x_finish, y_finish_, defaultMargin, x_axis :| y_axis :| lines)
  else:
    viewport(x_start, x_finish, y_finish, 0, lines)

# Plot a chart of categorical values on the x-axis and renderings of the corresponding a-value on the y-axis.
# (Colours -> List a -> GraphicsElement) -> Bool -> Colours -> Float -> List (Cat, a) -> GraphicsElement
def categoricalChart(plotValue, withAxes, colours, sep, data):
  def gs:
    stackRight(sep, plotValue(colours, map(snd, data)))
  def w: length(gs)
  def h: maximum(map(height, gs))

  if withAxes:
    def x_axis: catAxis(Horiz, 0, map(fst, data))
    def (y_axis, h_): axis(Vert, 0, 0, h)
    viewport(0, w, h_, defaultMargin, concat2(gs, [x_axis, y_axis]))
  else:
    viewport(0, w, h, 0, gs)

# Colours -> List a -> GraphicsElement
def rects(colours, ns):
  zipWith(lambda colour, n: Rect(0, 0, 1, n, colour), colours, ns)

# First component of data (categorical value) currently ignored; values just mapped positionally to colors.
# Can we use Group instead of Viewport here?
# Colours -> List (a, Num) -> GraphicsElement
def stackedBar(colours, ns):
  def heights: map(snd, ns)
  def subtotals: scanl1((+), 0, heights)
  def dims: zip(0 :| subtotals, heights)
  def rects:
    map(lambda ((y, height), colour): Rect(0, y, 1, height, colour), zip(dims, colours))

  Viewport(0, 0, 1, last(subtotals), "none", 0, Scale(1, 1), Translate(0, 0), Group(rects))

# Bool -> Colours -> Float -> List (a, Float) -> GraphicsElement
def barChart:
  categoricalChart(rects)

# For each categorical value of type a, plot a bar chart for the corresponding b-indexed data.
# Bool -> Colours -> Float -> List (a, List (b, Float)) -> GraphicsElement
def groupedBarChart:
  categoricalChart(compose(map, flip(barChart(False), 0)))

# See stackedBar for strong (unjustified) assumption about uniformity of data.
# Bool -> Colours -> Num -> List (a, List (b, Num)) -> GraphicsElement
def stackedBarChart:
  categoricalChart(compose(map, stackedBar))

# Bit of a hack, but how text fits into our model is a bit unclear at the moment.
# Str -> GraphicsElement -> GraphicsElement
def caption(str, Viewport(x, y, w, h, fill, margin, scale, translate, g)):
  def g_:
    Group([
      String(x + w / 2, -2, str, "middle", "hanging"),
      Viewport(0, 0, w, h, fill, margin, scale, translate, g)
    ])

  Viewport(x, y, w, h, backgroundColour, defaultMargin / 2 + 4, Scale(1, 1), Translate(0, 0), g_)
